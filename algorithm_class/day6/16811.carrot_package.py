"""
이싸피는 싸피 식당에 당근을 공급하고 있다. 이싸피의 당근은 맛도 있지만, 영양분이 풍부해 당근을 먹은 사람들이 알고리즘 문제를 더 잘 풀게 된다고 한다. 하지만 이싸피도 싸피 식당의 복잡한 포장 조건 때문에 늘 고생하고 있다.
싸피식당의 요구 조건은 다음과 같다.

N개의 당근을 주문하면 대, 중, 소 상자로 구분해 포장해야 한다.
같은 크기의 당근은 같은 상자에 들어있어야 한다.
비어 있는 상자가 있으면 안 된다.
한 상자에 N/2개(N이 홀수면 소수점 버림)를 초과하는 당근이 있어서도 안 된다.
앞의 조건을 만족하면서도, 각 상자에 든 당근의 개수 차이가 최소가 되도록 포장해야 한다. 그리고 이때의 개수 차이를 서류에 표시 한다.
새로운 주문이 들어와 이싸피는 N개의 당근을 밭에서 뽑아왔다. 대, 중, 소 상자를 각각 저울에 올려 포장해보는 대신, 뽑은 당근의 크기를 입력하면 모든 조건을 확인하는 프로그램을 만들어 이싸피가 쉽게 당근을 포장할 수 있게 도와보자.
예시1)
뽑아온 당근이 3개이고, 크기가 1 2 3이라면 다음과 같이 포장할 수 있다.
소 [ 1 ], 중 [ 2 ], 대 [ 3 ], 상자에 든 당근의 개수 차이는 0
예시2)
당근이 5개이고 크기가 1 1 1 2 3 이라면, 조건 (1)~(3)을 만족하는 포장은 다음과 같다.
           소[ 1 1 1 ], 중 [ 2 ], 대 [ 3 ], 당근의 개수 차이는 2
하지만 이 경우 5/2개(2개)를 초과하는 상자가 있으므로 조건(4)를 만족하지 못한다.
예시3)
당근이 8개 이고, 크기가 1 2 3 4 5 6 7 8인 경우이다. 우선 다음과 같이 포장할 수도 있다.
           소[ 1 2 3 4 ], 중[ 5 ], 대[ 6 7 8 ], 당근의 개수 차이는 3
하지만 다음과 같이 포장해야 조건(5)를 만족한다.
           소[ 1 2 3 ], 중[ 4 5 6 ], 대[ 7 8 ], 당근의 개수 차이는 1
또는 다음과 같은 경우도 조건(5)를 만족한다.
           소[ 1 2 ], 중[ 3 4 5 ], 대[ 6 7 8 ], 당근의 개수 차이는 1
[입력]
첫 줄에 총 수확 횟수 T가 주어진다.
각 수확에 대해, 첫 줄에 당근의 개수N, 다음 줄에 수확한 N개의 당근 크기 Ci가 빈칸으로 구분되어 주어진다. ( 3<=N<=1000, 1<=Ci<=30 )
[출력]
#과 1번부터인 수확번호에 이어, 포장 할 수 없는 경우 -1, 포장할 수 있으면 상자에 들어있는 당근의 개수 차이가 최소일 때의 차이값을 출력하라.
"""
t = int(input())

for test_case in range(1, t + 1):
    n = int(input())
    carrot_list = list(map(int, input().split()))
    carrot = sorted(carrot_list)
    carrot_diff = 1000   # n 이 최대 1000이다.

    for i in range(n-2):
        for j in range(i+1, n-1):   # 선생님이 알려준 모든 경우 탐색
            if carrot[i] != carrot[i+1] and carrot[j] != carrot[j+1]:   # 같은 것이 서로 다른 상자에 들어가지 않게 함.
                small = i + 1       # 작은 상자에는 0 ~ i 까지 갯수 합
                medium = j - i      # 중간 상자에는 j 에서 i를 빼준 값
                large = n - 1 - j   # 큰 상자에는 총 갯수인 n 에서 small, medium 값 빼준 값
                if small <= n // 2 and medium <= n // 2 and large <= n // 2:    # 절반을 넘지 않아야 한다.
                    min_val = min(small, medium, large)     # 세개 값 비교
                    max_val = max(small, medium, large)
                    diff = max_val - min_val
                    if carrot_diff > diff:      # 모든 경우 탐색하는 과정에서 더 작은 값 있으면 그 값 대입
                        carrot_diff = diff
    if carrot_diff == 1000:    # small <= n//2 문장에서 if문에 적합하지 않은 값 들어가면 포장 불가
        carrot_diff = -1

    print(f'#{test_case} {carrot_diff}')
